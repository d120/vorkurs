\input{preamble.tex}
\sheetnumber{3}
\title{Aufgaben Programmiervorkurs}
\subtitle{von der Fachschaft Informatik\hfill\ptitle}
\begin{document}
\maketitle{}

\begin{task}[points=auto]{Schleifen}
    \begin{subtask*}[points=0]{Gaußsche Summenformel Reloaded \stage1}
        Erinnert euch an die Gaußsche Summenformel aus Übungsblatt 1:
        $$1+2+3+\ldots+n = \sum_{k=1}^nk=\frac{n\cdot(n+1)}{2}$$
        Nun soll die Summe nicht mit Hilfe der geschlossenen Darstellung der Reihe berechnet werden, sondern unter Verwendung einer \textbf{for-Schleife}.

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                var summe = 0

                for (k in 1..100) {
                    summe += k
                }

                println("Die Summe von 1 bis 100 ist $summe.")
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Fakultät \stage1}
        \begin{enumerate}
            \item Schreibt ein Programm, das den Wert des Ausdrucks $1 \cdot 2 \cdot 3 \cdot \ldots \cdot 15 = 15!$ (Fakultät von 15) berechnet, und das Ergebnis auf der Konsole ausgibt.
            \item Erweitert euer Programm so, dass es von beliebigen Eingaben in der Konsole die Fakultät berechnet.
        \end{enumerate}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
            print("Welche Fakultät soll berechnet werden: ")
            val fak = readln().toInt()

            var erg = 1

            for (i in 1..fak) {
                erg *= i
            }

            println("Die $fak. Fakultät ist $erg")
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{FizzBuzz \stage3}
        FizzBuzz ist ein bekanntes \href{https://en.wikipedia.org/wiki/Fizz_buzz}{Lernspiel}. Schreibt ein Programm, das (zeilenweise) die Zahlen von 1 bis 100 ausgibt, aber für jedes Vielfache von 3 das Wort \textbf{Fizz} und für jedes Vielfache von 5 das Wort \textbf{Buzz} anstelle der Zahl ausgibt. Für Zahlen, die Vielfache von 3 und 5 sind, soll \textbf{FizzBuzz} ausgegeben werden.

        \textit{Hinweis: Im FizzBuzz-Fall soll \textbf{nur} FizzBuzz als \textbf{ein} Wort ausgegeben werden}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                for (zahl in 1..100) {
                    val istDurch3Teilbar = zahl % 3 == 0
                    val istDurch5Teilbar = zahl % 5 == 0

                    if (istDurch3Teilbar && istDurch5Teilbar) {
                        println("FizzBuzz")
                    } else if (istDurch3Teilbar) {
                        println("Fizz")
                    } else if (istDurch5Teilbar) {
                        println("Buzz")
                    } else {
                        println(zahl)
                    }
                }
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Primzahl \stage3}
        Gegeben ist folgendes Listing:
        \begin{codeBlock}[]{minted language=kotlin}
                val prime = 7 // Hier die Zahl

                var isPrime = true
                // Hier den Code einfügen

                if (isPrime) {
                    // Hier den Code einfügen
                } else {
                    // Hier den Code einfügen
                }
        \end{codeBlock}
        \begin{enumerate}
            \item Ergänzt das Programm. Es soll erkennen, ob es sich bei der Variable \textbf{prime} um eine Primzahl\footnote{\href{https://de.wikipedia.org/wiki/Primzahl}{Jede natürliche Zahl, die nur durch sich selbst und 1 teilbar ist.}} handelt. Testet euer Programm mit verschiedenen Werten.
            \item Erweitert das Programm um eine manuelle Eingabe der Primzahl.
        \end{enumerate}

        \begin{solution}
            \kotlinfile[][]{code/3_1_d_2_sol.kts}
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Listige Listen}
    \begin{subtask*}[points=0]{Definition und Indices \stage1}
        Beginnt ein neues Programm, und geht dabei davon aus, dass die Liste
        \kotlininline{liste} genau $8$ Elemente enthält. Euer Programm soll
        nun die Ergebnisse der folgenden Rechnungen ausgeben:

        \begin{enumerate}
            \item Die Summe der Zahlen an Index $1$, $2$ und $7$.
            \item Das Produkt jeder zweiten Zahl.
            \item Die erste Zahl mal 300.
        \end{enumerate}

        Für diese Aufgabe müsst ihr weder Schleifen noch Slicing verwenden. Probiert
        euer Programm aus, indem ihr die folgenden Listen einsetzt und die Ausgaben
        mit denen von eurem Programm vergleicht.

        \begin{itemize}
            \item Für \kotlininline{liste = listOf(1,1,2,3,5,8,13,21)} ist das $24$, $504$ und $300$
            \item Für \kotlininline{liste = listOf(-1,1,-1,1,-1,1,-1,1)} ist das $1$, $1$ und $-300$
        \end{itemize}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                // Hier die Liste einsetzen
                val liste = listOf(1,1,2,3,5,8,13,21)
                // val liste = listOf(-1,1,-1,1,-1,1,-1,1)

                val summe = liste[1] + liste[2] + liste[7]
                println("1. Die Summe der Zahlen an Index 1, 2 und 7 ist $summe")

                val produkt = liste[1] * liste[3] * liste[5] * liste[7]
                println("2. Das Produkt jeder zweiten Zahl ist $produkt")

                val sparta = liste[0] * 300
                println("3. Die erste Zahl mal 300 ergibt $sparta")
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Listenlänge \stage1}
        In der Vorlesung wurde \kotlininline{liste.size} eingeführt um die Länge einer
        Liste zu bestimmen. Überlegt euch warum der Ausdruck \kotlininline{liste[liste.size]}
        immer zu einem Fehler führt.

        Schreibt nun ein Programm, dass für beliebige Listen alle Elemente der Reihe
        nach ausgibt. Ihr könnt dafür eine \kotlininline{while}-Schleife verwenden.

        \begin{solution}
            Da die Indices bei 0 anfangen ist \kotlininline{liste.size - 1} der letzte gültige Index.

            \begin{codeBlock}[]{minted language=kotlin}
                val list = listOf(1, 2, 3, 4, 5) // Beispiel-Liste

                var index = 0
                while (index < list.size) {
                    val element = list[index]
                    println("Element $index: $element")
                    index++
                }
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Fortgeschrittenes Lesen}
    \begin{subtask*}[points=0]{Einer für alle und alle für einen! \stage2}
        Slicing ermöglicht es, nur einen Teil einer Liste zu verwenden.
        So gilt etwa \\\kotlininline{listOf(1, 2, 3, 4).slice(1..2) == listOf(2, 3)}.
        Ein Slicing bekommt, wie bei Schleifen, eine Range \kotlininline{a..b step c}.
        Was kann weggelassen werden. Welchen Wert wird verwendet,
        wenn dieser leer gelassen werden?

        Was ist der Unterschied zwischen \kotlininline{a .. b}
        und \kotlininline{a until b}?

        Wie geht man von großen zu kleinen Zahlen?

        \begin{solution}
            Man kann \kotlininline{step c} weglassen.
            Dann wird \kotlininline{step 1} genutzt.

            Bei \kotlininline{until} wird schon vor \kotlininline{b} gestoppt.

            \kotlininline{10 downTo 0} ist eine Möglichkeit.
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Slicing-Beispiele \stage2}
        Findet Slicing-Ausdrücke für die folgenden Fragen zur Liste \kotlininline{liste}:

        \begin{enumerate}
            \item Die gesamte Liste
            \item Die Liste rückwärts
            \item Jedes zweite Element
            \item Das erste Element und jedes dritte danach mit Indices kleiner $7$
            \item Elemente an Index $6$, $5$, $4$ und $3$
            \item Nur das erste Element
        \end{enumerate}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                val liste = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)

                println(liste.slice(0 until liste.size))   // [1, 2, 3, 4, 5, 6, 7, 8, 9]
                println(liste.slice(liste.size - 1 downTo 0))  // [9, 8, 7, 6, 5, 4, 3, 2, 1]
                println(liste.slice(1 until liste.size step 2))  // [2, 4, 6, 8]
                println(liste.slice(0..6 step 3))       // [1, 4, 7]
                println(liste.slice(6 downTo 2))        // [7, 6, 5, 4]
                println(liste.slice(0 until 1))         // [1]
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Listenverarbeitung}
    \begin{subtask*}[points=0]{Zahlenlisten \stage2}
        In der Vorlesung wurden Ranges \kotlininline{a .. b} vorgestellt. Wenn ihr diesen
        Ausdruck in den Interpreter eingebt, wird euch nur ein Ausdruck angezeigt der
        dieselbe Zahlenreihe meint. Mit \kotlininline{(a .. b).toList()} könnt ihr diesen
        Ausdruck in eine Liste umwandeln und euch anzeigen lassen. \\\\
        \textit{Welche range-Ausdrücke ergeben die folgenden Listen?}

        \begin{enumerate}
            \item \kotlininline{[1, 2, 3, 4, 5, 6, 7]}
            \item \kotlininline{[0, 1, 2, 3, 4]}
            \item \kotlininline{[4, 6, 8, 10]}
            \item \kotlininline{[9, 6, 3]}
        \end{enumerate}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                println((1..7).toList())
                println((0..4).toList())
                println((4..10 step 2).toList())
                println((9 downTo 3 step 3).toList())
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Text-Slicing \stage3}
        Slicing funktioniert auch mit Text. Dabei wird der Text wie eine Liste von
        Buchstaben behandelt. \\
        \kotlininline{"Hallo Welt!".slice(0 .. 4)} ergibt beispielsweise
        den String \kotlininline{"Hallo"}. Findet ihr einen Ausdruck mittels Slicing ein
        Palindrom erkennt? \textit{Ein Palindrom ist ein Wort, das vorwärts und rückwärts
            identisch ist}.

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                print("Gib hier dein Wort ein: ")
                val test = readln()

                val fullLength = test.length
                val halfLength = fullLength / 2

                if (test.slice(0 until halfLength) == test.slice(fullLength-1 downTo fullLength - halfLength)) {
                    println("Palindrom")
                } else {
                    println("Kein Palindrom")
                }

                // Kurze Lösung
                if (test == test.reversed()) {
                    println("Palindrom")
                } else {
                    println("Kein Palindrom")
                }
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Akkumulator \stage2}
        Häufig gibt es in Programmen eine Variable in der das Ergebnis langsam aufgebaut
        wird. Beispielsweise ist diese für eine Summe zu Anfang $0$. Danach wird diese
        in einer Schleife für jeden Eintrag verändert. Schreibe in Programm, was die
        für die Liste \kotlininline{[1, 2, 3, 4, 5, 6, 7]} die folgenden Werte berechnet:

        \begin{enumerate}
            \item Die Summe aller Elemente
            \item Das Produkt aller Elemente
            \item Der Durchschnitt aller Elemente
            \item Eine Liste der Quadrate der Elemente
        \end{enumerate}

        Was müsst ihr bei der Berechnung des Durchschnitts beachten?

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                val liste = listOf(1, 2, 3, 4, 5, 6, 7)

                var summe = 0
                var produkt = 1
                val quadrate = mutableListOf<Int>()

                for (zahl in liste) {
                    summe += zahl
                    produkt *= zahl
                    quadrate.add(zahl * zahl)
                }

                println(summe)
                println(produkt)
                println(if (liste.isNotEmpty()) summe.toDouble() / liste.size else "Leere Liste!")
                println(quadrate)
            \end{codeBlock}
        \end{solution}
    \end{subtask*}
\end{task}
\end{document}
