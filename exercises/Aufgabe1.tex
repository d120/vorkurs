\input{preamble.tex}
\sheetnumber{1}
\title{Aufgaben Programmiervorkurs}
\subtitle{von der Fachschaft Informatik\hfill\ptitle}
\begin{document}
\maketitle{}

\begin{task}[points=auto]{Einleitung}
    \begin{subtask*}[points=0]{Kotlin Installieren}
        Hey, willkommen bei den Übungen zum Programmiervorkurs im \ptitle. Wie in der
        Vorlesung verwenden wir für die Übungen die Programmiersprache Kotlin. \\\\
        %
        Auf den Poolrechnern und auf den meisten Linux-Distributionen sollte die
        benötigte Version 1.8.22 schon installiert sein. Prüft das, indem ihr (etwa mit
        Rechtsklick $\to$ \textit{Terminal öffnen}) auf dem Desktop) ein Terminal öffnet,
        und führt den Befehl {\ttfamily kotlin -version} aus. Dieser sollte so etwas wie
        {\ttfamily Kotlin version 1.8.22} ausgeben.

        Auf euren eigenen Geräten funktioniert das wahrscheinlich nicht so einfach, dort müsstet ihr Kotlin erst installieren.
        Dafür haben wir euch in Moodle eine separate Anleitung bereit gestellt.

        Führt nun den Befehl {\ttfamily kotlin} aus um eine interaktive Eingabezeile zu starten.

        Wenn ihr bei der Installation oder den Aufgaben nicht weiterkommt, fragt uns einfach! Es mag vielleicht nach einer guten Idee aussehen, im Internet nach der Antwort zu suchen, aber da habt ihr dann keine Garantie, dass es eine sinnvolle Erklärung dazu gibt. Außerdem wisst ihr dann nicht, ob ihr vielleicht etwas nicht richtig verstanden habt. Zu guter Letzt gibt es für viele der Probleme, die wir euch hier Präsentieren, sehr schnelle Lösungen in Kotlin, welche aber höhere Programmierkenntnisse voraussetzen. Ziel ist es nicht, möglichst alle Aufgaben richtig zu beantworten, sondern dass ihr versteht, was ihr dabei tun müsst.
        \begin{solution}
            Kotlin ist installiert und dem Pfad hinzugefügt. Der Befehl
            {\ttfamily kolin -version} gibt eine Versionsnummer von mindestens {\ttfamily 1.8.22} aus.
            Der Kotlin Interpreter wurde gestartet.
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Theoriefragen}
        \subsection{Theoriefragen}
        \begin{itemize}
            \mchead
            \mcitemt{Programmcode steht üblicherweise in Textdateien}
            \mcitemf{Ein Prozessor kann Kotlin direkt ausführen}
            \mcitemt{Um Kotlin-Code auszuführen kann ein Interpreter verwendet werden}
            \mcitemf{Es ist niemals sinnvoll seinen Code mit Kommentaren zu überladen}
        \end{itemize}
        \begin{solution}
            Die zutreffenden Antworten sind die Aussagen 1 und 3.
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Ausdrücke \stage1}
    \begin{subtask*}[points=0]{Frage \& Antwort}
        Gebt nacheinander die folgenden Ausdrücke in den Interpreter ein. Drückt nach
        jedem Eintrag \textit{ENTER}, um den Ausdruck auszuwerten. Was passiert?
        Versucht, zu erklären, warum. Probiert auch noch weitere Ausdrücke, die euch
        einfallen.

        \begin{multicols}{3}
            \begin{itemize}
                \item {\ttfamily 2}
                \item {\ttfamily 10.0}
                \item {\ttfamily \verb="1"=}
                \item {\ttfamily '1'}
                \item {\ttfamily Test}
                \item {\ttfamily \verb="Test"=}
                \item {\ttfamily 0x11}
                \item {\ttfamily 0b11}
                \item {\ttfamily true}
                \item {\ttfamily True}
                \item {\ttfamily false}
                \item {\ttfamily False}
            \end{itemize}
        \end{multicols}

        \bonus{Kotlin gibt nicht nur den Wert eines Ausdrucks,
            sondern auch seinen Typ an.}

        \begin{solution}
            Zahlen ohne Anführungszeichen ergeben die Zahl. Rationale Zahlen brauchen einen
            Dezimal\textbf{punkt}. Doppelte Anführungszeichen ({\ttfamily \verb+"+}) ergeben Strings,
            der Prefix {\ttfamily 0x} erwartet hexadezimales Format, der Prefix {\ttfamily 0b}
            binäres Format. Wahrheitswerte müssen klein geschrieben werden ({\ttfamily true},
            {\ttfamily false})
            Einfache Anführungszeichen ergeben Chars, hier wird ein einzelnes Zeichen als numerischer Wert abgespeichert.
            Strings sind dann die Verkettung von Chars.
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Mathe 0 für Informatiker*innen}
        Wenn euch das Programm aber nur das zurückgeben könnte, was ihr hinschreibt,
        dann wäre das ja noch lange kein \textit{Computer}. Darum rechnen wir nun etwas.
        Überlegt euch was die folgenden Ausdrücke ergeben, und was die verwendeten
        Symbole für Operationen bezeichnen. Beachtet dabei, die Operatorenpräzedenz.

        \begin{multicols}{3}
            \begin{itemize}
                \item {\ttfamily 16 + 26}
                \item {\ttfamily 13.75 + 28.67}
                \item {\ttfamily 2 * 3 + 6 * 6}
                \item {\ttfamily \verb="4" + 2=}
                \item {\ttfamily 12 * 133 / 28 - 15}
                \item {\ttfamily \Verb{'a' + 5}}
                \item {\ttfamily 1.3 * 5.6}
            \end{itemize}
        \end{multicols}

        \bonus{Weitere mathematische Operationen können mit {\ttfamily import kotlin.math.*} importiert werden.

        \begin{multicols}{3}
            \begin{itemize}
                \item {\ttfamily PI}
                \item {\ttfamily 12.0.pow(3)}
                \item {\ttfamily sqrt(2.0)}
            \end{itemize}
        \end{multicols}}

        \begin{solution}
            Das Ergebnis ist meistens eine Variante von 42.
            Wichtig ist, dass hier Punkt- vor Strichrechnung gilt.
            Beachtet die unterschiedlichen Datentypen.
            Die letzte Aufgabe betont, dass manche Operationen auf Kommazahlen keine genauen Ergebnisse liefern.
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Konvertierung \stage2}
    \begin{subtask*}[points=0]{Konvertierung}
        Nehmen wir mal an, ihr habt den Text {\ttfamily \verb="1000"=} zur Verfügung. Vielleicht
        errechnet; vielleicht aus einer API (\textit{application programming interface}, allgemeine Bezeichnung für Schnittstellen zwischen Programmen)? Es kommt immer wieder vor, dass die Daten noch den falschen Typ haben, wenn ihr sie bekommt.

        Gebt die folgenden Ausdrücke ein, und findet das Ergebnis heraus.

        \textit{Hinweis: es kann sein, dass einige Konvertierungen fehlschlagen. In diesem Fall überlegt euch, warum. Die Fehlermeldung kann dabei hilfreich sein.}

        \begin{multicols}{3}
            \begin{enumerate}
                \item \pythoninline{"100".toInt()}
                \item \pythoninline{"1.3".toFloat()}
                \item \pythoninline{"NaN".toFloat()}
                \item \pythoninline{123.toString()}
                \item \pythoninline{"0x11".toInt()}
                \item \pythoninline{2.toString() + "5"}
                \item \pythoninline{(2 + 5).toString()}
                \item \pythoninline{5.toFloat()}
                \item \pythoninline{5.5.toInt()}
                \item \pythoninline{"4.2".toInt()}
            \end{enumerate}
        \end{multicols}

        \begin{solution}
            \begin{multicols}{3}
                \begin{enumerate}
                    \item \pythoninline{kotlin.Int = 100}
                    \item \pythoninline{kotlin.Float = 1.3}
                    \item \pythoninline{kotlin.Float = NaN}
                    \item \pythoninline{kotlin.String = 123}
                    \item \textbf{NumberFormatException}
                    \item \pythoninline{kotlin.String = 25}
                    \item \pythoninline{kotlin.String = 7}
                    \item \pythoninline{kotlin.Float = 5.0}
                    \item \pythoninline{kotlin.Int = 5}
                    \item \textbf{NumberFormatException}
                \end{enumerate}
            \end{multicols}
        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Verrückte Eingabe \stage3}
        Versucht einen Ausdruck zu finden, der nur \pythoninline{'1'}, \pythoninline{0},
        \pythoninline{toInt}, \pythoninline{toString} und Operationen verwendet, der
        insgesamt zu \pythoninline{3000} auswertet. Beachtet, dass solche Ausdrücke
        wie ihr hier schreiben sollt, so \textbf{niemals} in echtem Code auftauchen
        sollten.

        \textit{Hinweis: Zwar soll am Ende eine Zahl rauskommen, ihr werdet aber in dieser Aufgabe oft zwischen Zahl und Text hin- und herkonvertieren müssen.}

        \begin{solution}
            \begin{codeBlock}[]{minted language=kotlin}
                >>> (("1".toInt() + "1".toInt() + "1".toInt()).toString() + 0.toString() + 0.toString() + 0.toString()).toInt()
                res4: kotlin.Int = 3000
            \end{codeBlock}
            Es gibt natürlich auch noch andere Möglichkeiten.
        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Fehler}
    \begin{subtask*}[points=0]{Fehlertypen \stage1}

        Ordnet die folgenden drei Fehlertypen den folgenden Ausdrücken zu.
        \begin{multicols}{3}
            \begin{itemize}
                \item[] \textbf{expecting an expression}
                \item[] \textbf{ArithmeticException}
                \item[] \textbf{unresolved reference}
            \end{itemize}
            \begin{itemize}
                \item[] \pythoninline{True}
                \item[] \pythoninline{2.toInt)3(}
                \item[] \pythoninline{2 / 0}
            \end{itemize}
            \begin{itemize}
                \item[] \textit{Syntaktischer Fehler}
                \item[] \textit{Lexikalischer Fehler}
                \item[] \textit{Semantischer Fehler}
            \end{itemize}
        \end{multicols}

        \begin{solution}
            \begin{enumerate}
                \item \pythoninline{True} ist ein falsch geschriebenes Schlüsselwort und somit ein \\
                    lexikalischer Fehler (unresolved reference)
                \item \pythoninline{2.toInt)3(} hat die Klammern vertauscht, somit ein \\
                    syntaktischer Fehler (expecting an expression)
                \item \pythoninline{2 / 0} ist eine undefinierte Rechnung, also ein
                    \\ semantischer Fehler (\textbf{ArithmeticException})
            \end{enumerate}

        \end{solution}
    \end{subtask*}
    \begin{subtask*}[points=0]{Finde den Fehler \stage2}
        Gegeben sind die folgenden Listings. Führt die Programme aus und beschreibt, warum jeweils ein Fehler auftritt.
        \begin{codeBlock}[]{minted language=kotlin}
            >>> prinntln("Hello World!") // a)
            >>> println(Hello World!)    // b)
            >>> println("Alter: " + 18)  // c)
            >>> println("Hello World!)   // d)
        \end{codeBlock}
        \begin{solution}
            \begin{enumerate}
                \item {\ttfamily unresolved reference: prinnt}: Ein \textcolor{red}{Lexikalischer Fehler}, da es keine Funktion mit dem angegebenen Namen
                    \texttt	{prinnt} gibt. Gültig wäre {\ttfamily println}. Ein klassische Tippfehler.
                \item {\ttfamily SyntaxError: invalid syntax}: Ein \textcolor{red}{Syntaktischer Fehler}, da Strings immer in einfachen oder doppelten Anführungszeichen
                    stehen müssen.
                \item {\ttfamily TypeError: must be str, not int}: Ein \textcolor{red}{Semantischer Fehler}, da Texte und Zahlen nicht eindeutig addierbar sind.
                    \textbf{Bonus Fact}: Um irgendeinen Wert in einen String zu verwandeln gibt es die Funktion {\ttfamily str(...)}
                \item {\ttfamily SyntaxError: EOL while scanning string literal}: Ein \textcolor{red}{Syntaktischer Fehler}, da der Rest der Zeile nun auch als String
                    gelesen wird, der aber nie endet.
            \end{enumerate}

        \end{solution}
    \end{subtask*}
\end{task}
\begin{task}[points=auto]{Challenge}
    \begin{subtask*}[points=0]{Wir rechnen Modulo \stage3}
        %\newcommand{\mod}{\mathop{mod}}

        Für eine RSA-Verschlüsselung werden zwei Primzahlen $p,q$ benötigt.
        Deren Produkt definiert einen Ring $\mathbb Z_n$ mit $n = p * q$.
        Das heißt, nach jeder Operation wir das Ergebnis mittels \textbf{Modulo}
        in das Intervall $[0,n)$ gebracht. \\\\
        %
        In Python wird das mit dem {\ttfamily \%} Operator dargestellt. So gilt
        \pythoninline{20 % 10 == 0}, \pythoninline{15 % 9 == 6}, \dots \\\\
        %
        Wenn wir nun etwas verschlüsseln/entschlüsseln wollen, benötigen wir zunächst
        $N = \phi(n) = (p-1) * (q-1)$ und ausserdem ein $0 < e < N$ mit $ggT(e,N) = 1$,
        sowie ein $0 < d < N$ mit $ed \mod N = 1$. \\\\
        %
        Da das hier keine Krypto-Vorlesung ist, haben wir für euch die Werte: \\
        $p=3$, $q=11$, $n=33$, $N=20$, $e=3$, $d=7$ berechnet. Eine Nachricht $m$ wird
        nun als $m^e \mod n$ verschlüsselt, ein Chiffretext $c$ als $c^d \mod n$
        entschlüsselt.\\\\
        %
        Verschlüsselt mit den vorgegebenen (oder eigenen) Werten nun ein
        paar Zahlen ($0 <= x < n$), und probiert ob ihr sie wieder entschlüsseln könnt.
        Ihr könnt diese auch an eure Sitznachbarn weitergeben!

        % Bonus
        % enc = lambda x: [(ord(c) - ord('a')) ** 3 % 33 for c in x if ord('a') <= ord(c) and ord(c) <= ord('z')]
        % dec = lambda x: "".join([chr((v ** 7 % 33) + ord('a')) for v in x if 0 <= v and v < 33])
        \begin{solution}
            Ein Beispiel wäre die folgende Rechnung:
            \begin{codeBlock}[]{minted language=python}
                >>> (13 ** 3) % 33
                19
                >>> (19 ** 7) % 33
                13
            \end{codeBlock}

        \end{solution}
    \end{subtask*}
\end{task}
\end{document}
