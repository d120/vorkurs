% !TeX document-id = {ecbf6175-be07-4601-b8eb-d3263d2bff07}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
% !TeX root = 02_Operatoren.tex
\input{../global.tex}

\begin{document}

\subtitle{Kapitel 2: Operatoren}
\titlegraphic{
    \tikzstyle{rect} = [rectangle, rounded corners, minimum width=2.5cm, minimum height=1cm,text centered, draw, text width=5cm, fill=\IfDarkModeTF{red!30!black}{red!10}]
    \centering
    \begin{tikzpicture}[node distance=.7cm]
        \node[inner sep=.3cm] (0) {\Huge Operatoren};
        \node[rect, below=.3cm of 0] (1) {\textbf{Mathematische Operatoren}};
        \node[rect, below=.2cm of 1] (2) {\textbf{Vergleichsoperatoren}};
        \node[rect, below=.2cm of 2] (3) {\textbf{Logische Operatoren}};
    \end{tikzpicture}
}
\maketitle

% Für die*den Programmieranfänger*innen mag es zwar total normal scheinen, dass man Kommazahlen mit Integers addieren kann, aber für den Computer ist das ein wichtiger Unterschied! Jetzt kommt der Moment wo ich alle überzeugen kann, dass der Computer wirklich komplett anders denkt als wir Menschen. Er hat ein komplett anderes Konzept, sich 0.1 vorzustellen.

%Umfrage, glaubt ihr Computer können rechnen?

\section{Mathematische Operatoren}
\subsection{Python als Taschenrechner}
\begin{frame}
    \slidehead
    \begin{itemize}[<+->]
        \item Man kann mit ganzen Zahlen , z.B. \pythoninline{0, 1, -69, 420}, rechnen
            \begin{itemize}
                \item \dots wird in Python \pythoninline{int} genannt.
            \end{itemize}
        \item Alternativ mit Kommazahlen, z.B. \pythoninline{0.0, 1.0, -420.69, 3.14159, 2.7}.
            \begin{itemize}
                \item \dots wird in Python \pythoninline{float} genannt.
            \end{itemize}
        \item Kommazahlen sind ungenau: \pythoninline{0.1 + 0.2}.
        \item Python kann \pythoninline{+, -, *, /} rechnen.
        \item Es gibt noch weitere Operationen, z.B. \pythoninline{**, //,} {\color{gray} \%}.
        \item Eine Liste aller Operationen kann man mit \pythoninline{help("+")} anzeigen.
        \item Es gibt Punkt-vor-Strich bzw. PEMDAS.
        \item Man kann klammern \pythoninline{()} wie gewohnt.
    \end{itemize}
\end{frame}

\section{Operatorpräzedenz}
\begin{frame}
    \slidehead

    \kotlinfile{listings/rangfolge_basic.kts}
    \pause
    \kotlinfile{listings/rangfolge_parenthesis.kts}
    \pause
    \begin{itemize}
        \item Die Operatorpräzedenz gibt die \textbf{Reihenfolge} vor, in der Ausdrücke ausgewertet werden:
            \begin{enumerate}
                \item Arithmetische Ausdrücke
                    \begin{itemize}
                        \item[$\Rightarrow$] Wie aus Schulmathematik bekannt
                    \end{itemize}
                \item Vergleiche
                \item Logische Ausdrücke (hierzu später mehr)
                \item Zuweisungen
            \end{enumerate}
    \end{itemize}
\end{frame}

\livecoding

\section{Vergleichsoperatoren}
\subsection{Erzeugen von Wahrheitswerten}
\begin{frame}
    \slidehead

    \begin{center}
        \vskip -7 pt
        \begingroup
        \fontsize{10pt}{11pt}\selectfont
        \begin{tabular}{|l|>{\ttfamily}c|>{\ttfamily}c|>{\ttfamily}c|}
            \hline
            \textbf{Operator}       & \textbf{Symbol} & \textbf{Beispiel}        & \textbf{Rückgabewert} \\ \hline
            gleich                  & ==              & \pythoninline{100 == 50} & \pythoninline{False}  \\
                                    &                 & \pythoninline{50 == 50}  & \pythoninline{True}   \\ \hline
            ungleich                & !=              & \pythoninline{100 != 50} & \pythoninline{True}   \\
                                    &                 & \pythoninline{50 != 50}  & \pythoninline{False}  \\ \hline
            größer als              & >               & \pythoninline{100 > 50}  & \pythoninline{True}   \\
                                    &                 & \pythoninline{50 > 50}   & \pythoninline{False}  \\ \hline
            größer als oder gleich  & >=              & \pythoninline{100 >= 50} & \pythoninline{True}   \\
                                    &                 & \pythoninline{50 >= 50}  & \pythoninline{True}   \\ \hline
            kleiner als             & <               & \pythoninline{100 < 50}  & \pythoninline{False}  \\
                                    &                 & \pythoninline{50 < 50}   & \pythoninline{False}  \\ \hline
            kleiner als oder gleich & <=              & \pythoninline{100 <= 50} & \pythoninline{False}  \\
                                    &                 & \pythoninline{50 <= 50}  & \pythoninline{True}   \\ \hline
        \end{tabular}
        \endgroup
    \end{center}
\end{frame}

\livecoding

\section{Logische Operatoren}
\subsection{Vernüpfen von Vergleichsoperatoren}
\begin{frame}
    \slidehead
    \pause
    \begin{itemize}[<+->]
        \item Logisches \textbf{Nicht} (\pythoninline{not})  $\Rightarrow$ \pythoninline{not Ausdruck1}
        \item Logisches \textbf{Und} (\pythoninline{and}) $\Rightarrow$ \pythoninline{Ausdruck1 and Ausdruck2}
        \item Logisches \textbf{Oder} (\pythoninline{or})  $\Rightarrow$ \pythoninline{Ausdruck1 or Ausdruck2}
    \end{itemize}
    \pause
    \pythonfile[][top=0cm,bottom=0cm]{listings/logische_operatoren_listing.py}
    \pause
    \begin{block}{Hinweis}
        \begin{itemize}[<+->]
            \item Auswertung in der Reihenfolge \pythoninline{not}, \pythoninline{and} und dann \pythoninline{or}
            \item Reihenfolge immer beachten!
                Klammern setzen falls nötig!
        \end{itemize}
    \end{block}
\end{frame}

\livecoding


\section{Quiz}
\begin{frame}
    \slidehead
    \begin{itemize}[<+->]
        \item Wo liegt der Unterschied zwischen \pythoninline{int} und \pythoninline{float}?
        \item In welcher Reihenfolge wird \pythoninline{2 + 4 * 2 == 9} ausgewertet?
        \item Was ist das Ergebnis?
        \item In welcher Reihenfolge wird \pythoninline{1 < 7 and 7 < 10} ausgewertet?
        \item Was ist das Ergebnis?
    \end{itemize}
\end{frame}

\end{document}
