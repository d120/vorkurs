% !TeX document-id = {ce0a7a56-eb5e-4d6d-848f-46fb4968468e}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
\input{../global.tex}

\begin{document}

%Deckblatt
\titlegraphic*{\includegraphics{media/cern.jpg}}
% Photo by Samuel Zeller on Unsplash.  Source: https://unsplash.com/photos/JuFcQxgCXwA Licence is completely free to do anything: "More precisely, Unsplash grants you an irrevocable, nonexclusive, worldwide copyright license to download, copy, modify, distribute, perform, and use photos from Unsplash for free, including for commercial purposes, without permission from or attributing the photographer or Unsplash."

\subtitle{Listen}
\maketitle

%Inhaltsverzeichnis
\tocslide

\section{Listen?}
\begin{frame}
	\slidehead
	\pythonfile{listings/no_list.py}
\end{frame}

\begin{frame}
	\slidehead
	\pythonfile{listings/no_list_for.py}
\end{frame}


\section{Adressierung}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Liste: Kann mehrere Werte aufnehmen
		\item Metapher: Schuhkarton mit vielen Fächern
	\end{itemize}

	%list graphic
	%its beautiful
	%best regard
	%Kevin O.
	\begin{figure}[!h]
		\centering

		\begin{tikzpicture}
			\newcount\foo
			\foo=10
			\loop
			\draw[draw=., ultra thick] (11+\foo*0.5,0) rectangle ++(0.5,0.5);
			\advance \foo -1
			\node at (11.75+\foo*0.5, 0.75) {\the\foo};
			\ifnum \foo>0
			\repeat

			\draw [->, ultra thick] (12.5,-0.25) -- (11.5,-0.25);
			\node at (14, -0.25) {Listenlänge ist 10};
			\draw [->, ultra thick] (15.5,-0.25) -- (16.5,-0.25);

			\draw [-, ultra thick] (11.5,0.75) -- (11.2,0.75);
			\node at (10.5, 0.75) {Indizes};

			\draw [-, ultra thick] (16.25,0.25) -- (17.0,1);
			\node at (17.5, 1.25) {Element an Index 9};

		\end{tikzpicture}

	\end{figure}
	\pause
	Beispiel:\\
	\pythoninline{eineListe = [1, 2, 5, 9]}
	\begin{itemize}
		\item Der Wert 1 steht an Index 0
		\item Der Wert 2 steht an Index 1
		\item Der Wert 5 steht an Index 2 ...
		\item Die Liste hat eine Länge von 4
	\end{itemize}
\end{frame}

\subsection{Negative Adressierung}
\begin{frame}
	\slidehead
	\begin{itemize}
		\item Der Index -1 gibt das letzte Element zurück
		\item -2 das zweite Element von hinten
		\item ...
	\end{itemize}
\end{frame}

\section{Syntax}
\begin{frame}
	\slidehead
	\only<1>{\pythonfile{listings/list_syntax_no_solution.py}}
	\only<2>{\pythonfile{listings/list_syntax.py}}
\end{frame}

\section{Zugriffsfehler}
\begin{frame}
	\slidehead
	\pythonfile{listings/OutofBounce_Listing.py}
	Bedeutung:
	\begin{itemize}
		\item In Zeile 3 der Datei \texttt{dateiName.py} wurde ein Index angefordert, der nicht innerhalb der Liste liegt
	\end{itemize}

\end{frame}


\section{Nützliche Listen-Funktionen}
\begin{frame}
	\slidehead
	\begin{itemize}
		\item Länge einer Liste:
		\only<1>{\pythonfile{listings/list_length_no_solution.py}}
		\only<2>{\pythonfile{listings/list_length.py}}
	\end{itemize}
\end{frame}

\begin{frame}
	\slidehead
	\begin{itemize}
		\item Element an Liste anhängen:
		\pythonfile{listings/list_append.py}
		\pause
		\item Element aus Liste entfernen:
		\pythonfile{listings/list_pop.py}
	\end{itemize}
\end{frame}

\livecoding

\section{Listen-Slicing}
\begin{frame}
	\slidehead
	\begin{itemize}
		\item Listen können mittels Slicing zugeschnitten werden
		\pause
		\item Dazu wird \textbf{[a:b]} hinter die Liste geschrieben
		\item Dabei ist \textbf{a} der Anfangsindex, und \textbf{b} der Endindex
		\pause
		\item Wichtig: Der Wert an Stelle \textbf{b} wird nicht mit kopiert
		\item Dies funktioniert auch mit Strings!
	\end{itemize}
	\pause
	\begin{block}{Beispiel:}
		\only<4>{\pythonfile{listings/simpleSlice_no_solution.py}}
		\only<5>{\pythonfile{listings/simpleSlice.py}}
	\end{block}
\end{frame}

\begin{frame}
	\slidehead
	\begin{itemize}
		\item Es ist möglich einen oder beide der Parameter wegzulassen
		\pause
		\item \textbf{[a:]} gibt alle Elemente ab \textbf{a} zurück
		\pause
		\item \textbf{[:b]} gibt alle Elemente bis (exklusive) \textbf{b} zurück
		\pause
		\item \textbf{[:]} gibt alle Elemente zurück
	\end{itemize}
	\pause
	\begin{block}{Beispiel:}
		\only<5>{\pythonfile{listings/partlySlice_no_solution.py}}
		\only<6>{\pythonfile{listings/partlySlice.py}}
	\end{block}
\end{frame}

\begin{frame}
	\slidehead
	\begin{itemize}
		\item Es ist auch möglich in einem Intervall zu slicen
		\pause
		\item Dazu wird ein dritter Parameter hinzugefügt: \textbf{[a:b:c]} gibt von \textbf{a} bis (exklusive) \textbf{b} jedes \textbf{c}-te Element aus
		\pause
		\item \textbf{[::-1]} gibt die Liste in umgekehrter Reihenfolge aus
	\end{itemize}
	\pause
	\begin{block}{Beispiel:}
		\only<4>{\pythonfile{listings/intervalSlice_no_solution.py}}
		\only<5>{\pythonfile{listings/intervalSlice.py}}
	\end{block}
\end{frame}

\livecoding

\section{For- vs. Foreach-Schleife}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Häufig soll nur durch eine Liste iteriert werden:
		\pythonfile{listings/foreach_Listing2.py}
		\pause

		\item Deshalb Foreach-Schleife:
		\pythonfile{listings/foreach_Listing.py}
	\end{itemize}
\end{frame}

\section{Listen kopieren}
\begin{frame}
	\slidehead
	\pythonfile{listings/listcopy1.py}
\end{frame}


\subsection{Analyse}
\begin{frame}
	\slidehead
	\vspace{2ex}
	\centering
	\begin{tikzpicture}
		\node[draw, thick] at (-1,0) {\pythoninline{meineListe}};
		\node[draw, thick] at (1,0) {\pythoninline{kopie}};

		\node[draw, thick, fill=lightpetrol] at (0,2) {Speicherbereich};

		\draw [->, ultra thick] (-1, 0.3) -- (-0.1,1.7);
		\draw [->, ultra thick] (1, 0.3) -- (0.1,1.7);
	\end{tikzpicture}

	\vspace{2ex}
	\begin{itemize}
		\item Bei der Zuweisung mit \textbf{=} wurde nur die Zieladresse
		kopiert
		\item Deshalb wird die gleiche Liste referenziert
		\item Eine Änderung von \pythoninline{kopie} bewirkt eine Änderung in \pythoninline{meineListe} (und umgekehrt)
	\end{itemize}
\end{frame}


\begin{frame}
	\slidehead
	\pythonfile{listings/listcopy2.py}
\end{frame}

\subsection*{Analyse}
\begin{frame}
	\slidehead

	\vspace{2ex}
	\centering
	\begin{tikzpicture}
		\node[draw, thick] at (-2,0) {\pythoninline{meineListe}};
		\node[draw, thick] at (2,0) {\pythoninline{kopie}};


		\node[draw, thick, fill=lightpetrol] at (-2,2) {Speicherbereich};

		\node[draw, thick, fill=lightpetrol] at (2,2) {Speicherbereich 2};

		\draw [->, ultra thick] (-2, 0.25) -- (-2,1.75);
		\draw [->, ultra thick] (2, 0.25)  -- (2,1.75);
	\end{tikzpicture}
	\vspace{2ex}

	\begin{itemize}
		\item \pythoninline{kopie} liegt nun in einem neuen, unabhängigen Speicherbereich
	\end{itemize}
\end{frame}

\subsection{""}
\livecoding

\section{Mehrdimensionale Listen}
\begin{frame}
	\slidehead
	\begin{columns}[T]
		\begin{column}{4cm}
			\centering
			\begin{tikzpicture}
				\foo=2
				\loop
				\advance \foo -1
				\node at (0.75+\foo*0.5, 2.25) {\the\foo};
				\ifnum \foo>0
				\repeat

				\foo=3
				\loop
				\advance \foo -1
				\node at (0.25, 1.75-\foo*0.5) {\the\foo};
				\ifnum \foo>0
				\repeat

				\node at (0.75, 1.75-\foo*0.5) {8};
				\node at (0.75, 1.25-\foo*0.5) {0};
				\node at (0.75, 0.75-\foo*0.5) {5};

				\node at (1.25, 1.75-\foo*0.5) {2};
				\node at (1.25, 1.25-\foo*0.5) {1};
				\node at (1.25, 0.75-\foo*0.5) {4};

				\newcount\X
				\newcount\Y
				\loop
				\Y = 0
				\advance \X by 1
				{%
				\loop
				\advance \Y by 1

				\draw[draw=., ultra thick] 	(\X*0.5,\Y*0.5) 	rectangle ++(0.5,0.5);

				\ifnum \Y <3
				\repeat
				}%
				\ifnum \X < 2
				\repeat
			\end{tikzpicture}
		\end{column}
		\begin{column}{7cm}
			\begin{itemize}
				\item Definition: \pythoninline{square =[[8, 0, 5], [2, 1, 4]]}
				\item Jede Dimension stellt man durch einen eigenen Index dar
				\item Adressierung: \pythoninline{square[Spalte][Zeile]}
				\item Länge:\\
				1. Dimension: \pythoninline{len(square)}\\
				2. Dimension: \pythoninline{len(square[0])} oder \pythoninline{len(square[1])}, \dots
				\item Nicht jede Spalte muss gleich viele Zeilen haben
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\subsection{Initialisieren}
\begin{frame}
	\slidehead
	\vskip -12pt
	\pythonfile{listings/mehrDimList_Initialisierung_Listing.py}
\end{frame}

\subsection{}
\livecoding

\section{Quiz}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Wie erhält man Zugriff auf die Länge einer Liste?
		\pause
		\item Wie greife ich auf das 5. Element einer Liste zu?
		\pause
		\item Wie wird eine zweidimensionale Liste adressiert? (Stichwort: Zeile/Spalte)
		\pause
		\item Wofür benötigen wir \pythoninline{copy()} und warum erzielt eine einfache Zuweisung
		nicht den gewünschten Effekt?
		\pause
		\item Wie schneide ich eine Liste hinter dem 3. Element ab?
	\end{itemize}
\end{frame}

\end{document}
