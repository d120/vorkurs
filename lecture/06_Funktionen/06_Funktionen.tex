% !TeX document-id = {d2a98428-ee0e-4def-9f4b-378c042e42ba}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
\input{../global.tex}


\begin{document}
%Deckblatt
\subtitle{Funktionen \& Rekursion}

\titlegraphic{
	für mehr Informationen siehe Foliensatz "`Funktionen \& Rekursion"'}
\maketitle

%Inhaltsverzeichnis
\tocslide

\section{Schlechtes Beispiel}
\begin{frame}
	\slidehead

	\vskip -10pt
	\pythonfile{listings/beispiel_schlecht.py}
	\small (Namen generiert auf www.listofrandomnames.com)
\end{frame}


\section{Gutes Beispiel}
\begin{frame}
	\slidehead
	\pythonfile{listings/beispiel_gut.py}
\end{frame}

\section{Idee von Funktionen}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Funktionalität \textbf{kapseln}: An einer Stelle zusammengefasst
		\item Weniger \textbf{Redundanz}: Keinen Code doppelt schreiben
		\item Einmal Code schreiben, danach nur an diese Stelle verweisen
	\end{itemize}
	\vspace{1cm}
	\begin{block}{Hinweis}
		Einige Funktionen haben wir schon kennengelernt, z.B. \pythoninline{print("Hello World")}
	\end{block}
\end{frame}

\section{Woraus besteht eine Funktion?}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Syntax: \pythonfile{listings/functionhead_parameter.txt}
		\pause

		\item Beispiel:\pythonfile{listings/functionhead_parameter_konkret.py}
	\end{itemize}
	\begin{block}{Wichtig!}
		\begin{itemize}
			\item Funktionen müssen definiert werden, bevor sie aufgerufen werden
			\item Bei mehreren Parametern werden diese mit \textbf{,} getrennt
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Dokumentation}
\begin{frame}
	\slidehead
	\begin{itemize}
		\item in Python wird Funktionsdokumentation mit drei doppelten Anführungszeichen eingeleitet
		\item die Dokumentation kann mehrere Zeilen haben
		\item sie sollte kurz erklären was die Funktion tut, was sie an Parametern erwartet und (falls vorhanden) was sie zurück gibt
	\end{itemize}
\end{frame}

\subsection{Return-Statement}
\begin{frame}
	\slidehead
	\begin{itemize}
		\item Funktionen können Rückgabewerte haben
		\item Dazu wird \pythoninline{return} gefolgt vom Rückgabewert geschrieben
		\item Beispiel: \pythoninline{return 42}
	\end{itemize}
\end{frame}

\begin{frame}
	\slidehead

	\pythonfile{listings/bsp_geometrie_3.py}
	\begin{block}{Achtung}
		Anweisungen nach dem \pythoninline{return} werden nicht mehr ausgeführt
	\end{block}
\end{frame}

\livecoding

\section{Fallbeispiel: Geometrie}
\begin{frame}
	\slidehead

	\begin{figure}
		\centering
		%Hinweis: dieses Bild wurde von uns erstellt und kann ohne Referenz verwendet werden.
		%Viele Grüße
		%Kevin
		\includegraphics[width=\textheight]{geometrie}
	\end{figure}
	\vspace{-10mm}
	\begin{itemize}
		\item Flächeninhalt eines Kreises
	\end{itemize}
\end{frame}

\subsection{Flächeninhalt eines Kreises}
\begin{frame}
	\slidehead
	\pythonfile{listings/bsp_geometrie_schlecht.py}

	\begin{block}{Problem}
		Immer, wenn irgendwo der Flächeninhalt gebraucht wird, muss er neu geschrieben werden $\Rightarrow$ Viel Code und viele mögliche Fehlerquellen
	\end{block}
\end{frame}

\begin{frame}
	\slidehead

	\begin{onlyenv}<1>
		\pythonfile{listings/bsp_geometrie_1.py}
	\end{onlyenv}

	\begin{onlyenv}<2>
		\pythonfile{listings/bsp_geometrie_2.py}
	\end{onlyenv}

\end{frame}

\subsection{Wiederverwendbarkeit}
\begin{frame}
	\slidehead

	\pythonfile{listings/reusability.py}
	\begin{block}{Hinweis}
		Nun kann die Funktion auch in anderen Funktionen verwendet werden.
		Bei Änderungen muss nur eine Stelle geändert werden.
	\end{block}
\end{frame}

\section{Vorteile von Funktionen}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item \textbf{Wiederverwendung} von Code $\Rightarrow$ Weniger Code schreiben
		\item \textbf{Redundanz} im Code verringern $\Rightarrow$ Veränderungen nur an einer Stelle
		\item \textbf{Blackbox}-Prinzip $\Rightarrow$ Details verstecken
	\end{itemize}
\end{frame}

\livecoding

\section{Scope}
\subsection{Lokale Variablen}
\begin{frame}
	\slidehead
	\pythonfile{listings/scope_1.py}
	\pause
	\pythonfile{listings/scope_error_1.txt}
	\begin{block}{Hinweis:}
		Variablen, die innerhalb einer Funktion erstellt werden, werden gelöscht, sobald die Funktion endet.
		Diese Variablen heißen \textbf{lokale Variablen}.
	\end{block}
\end{frame}

\subsection{Globale Variablen}
\begin{frame}
	\slidehead
	\pythonfile{listings/scope_2.py}
	\begin{itemize}
		\item Variablen die außerhalb von Funktionen erstellt wurden, werden als \textbf{globale Variablen} bezeichnet
		\item Auf globale Variablen kann auch in Funktionen zugegriffen werden
	\end{itemize}
\end{frame}

\begin{frame}
	\slidehead
	\pythonfile{listings/scope_3.py}
	\begin{itemize}
		\item Die globale Variable \pythoninline{zahl} bleibt unverändert
		\item Es wird eine lokale Variable mit dem \textit{gleichen} Namen erstellt
	\end{itemize}
\end{frame}

\livecoding

\section{Rekursion}
\begin{frame}[t]
	\slidehead

	\vskip -18 pt
	\begin{columns}
		\begin{column}{4.5cm}
			\vskip 5 pt
			\begin{itemize}
				\item Funktionen können sich selbst aufrufen
			\end{itemize}
		\end{column}

		\begin{column}{7cm}
			\begin{figure}
				\ifcsname vorkursRecurse\endcsname
					\includegraphics[width=\textwidth,page=24]{06_Funktionen_tmp.pdf}
				\fi
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[t]
	\slidehead

	\begin{itemize}
		\item Funktionen können sich mehrfach selbst aufrufen
	\end{itemize}

	\begin{columns}
		\begin{column}{5cm}
			\begin{figure}
				\ifcsname vorkursRecurse\endcsname
					\includegraphics[width=\textwidth,page=25]{06_Funktionen_tmp.pdf}
				\fi
			\end{figure}
		\end{column}

		\begin{column}{5cm}
			\begin{figure}
				\ifcsname vorkursRecurse\endcsname
					\includegraphics[width=\textwidth,page=25]{06_Funktionen_tmp.pdf}
				\fi
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\subsection*{Beispiel}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Fibonacci-Zahlen: \texttt{1, 1, 2, 3, 5, 8, 13, 8+13 = 21, ...}
		\begin{onlyenv}<1>
			\pythonfile{listings/bsp_recursion_1.py}
		\end{onlyenv}

		\begin{onlyenv}<2>
			\pythonfile{listings/bsp_recursion_2.py}
		\end{onlyenv}

		\item<2> Rekursionsanker sorgt für den Abbruch
	\end{itemize}

\end{frame}

\subsection{Rekursionsbaum}

%The biggest Latex Monstrosity ever conceived:
%greetings
%Kevin O.
\newcommand{\mytree}{
\ifnum \val = 0
\draw[draw=black, ultra thick] (\x,\y) rectangle 	++(0.75,0.75);
\node at (\x+0.375,\y+0.375) {f(\the\val)};
\fi
\ifnum \val = 1
\draw[draw=black, ultra thick] (\x,\y) rectangle 	++(0.75,0.75);
\node at (\x+0.375,\y+0.375) {f(\the\val)};
\fi
\ifnum \val > 1

\draw[draw=black, ultra thick] (\x,\y) rectangle ++(0.75,0.75);
\node at (\x+0.375,\y+0.375) {f(\the\val)};

\advance \val -1
\advance \y -2
\tmp=-\val*0.01
\advance \tmp -1

\advance \x \tmp
\draw [->, thick] (\x-\tmp,\y+2) -- (\x+0.75,\y+0.75);
\mytree;

\tmp=\val*0.01
\advance \tmp 1

\advance \x \tmp
\advance \val -1
\tmp=\val*0.01
\advance \tmp 1

\advance \x \tmp

\draw [->, thick] (\x-\tmp+0.75,\y+2) -- (\x,\y+0.75);
\mytree;

%everything back to normal
\tmp=-\val*0.01
\advance \tmp -1

\advance \val +2
\advance \x \tmp
\advance \y +2
\fi
}


\begin{frame}
	\slidehead
	\centering
	\begin{tikzpicture}[scale=.9, every node/.style={scale=1}]
		\newcount\val
		\newcount\x
		\newcount\y
		\newcount\tmp
		\val=4;
		\x=0;
		\y=0;
		\mytree;
	\end{tikzpicture}
\end{frame}



\subsection{Rekursive Summe in Python}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Aufgabe: Zahlen von 1 bis 4 zusammenzählen: \texttt{sum(4)} \pause
		\item \texttt{= 1 + 2 + 3 + 4} \pause
		\item \texttt{= (1 + 2 + 3) + 4} \pause
		\item \texttt{= sum(3) + 4}
	\end{itemize}
	\vspace{1em}
	\pause
	\pythonfile{listings/recursiveSum.py}
\end{frame}

\subsection{}
\livecoding

\section{Quiz}
\begin{frame}
	\slidehead

	\begin{itemize}
		\item Was bedeutet Kapseln?
		\pause
		\item Was ist ein Parameter?
		\pause
		\item Darf ich meine Funktion \pythoninline{while} nennen?
		\pause
		\item Braucht eine Funktion ein \pythoninline{return}-Statement?
		\pause
		\item Solltet ihr alle zur Ophase gehen?
	\end{itemize}
\end{frame}

\end{document}
