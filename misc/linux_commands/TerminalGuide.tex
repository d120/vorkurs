% !TeX document-id = {505cbeed-ac21-4fdd-a7f4-eefb28b91c1e}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
\RequirePackage{import}
\subimport{../../exercises}{preamble.tex}
\usepackage{hyperref}

\title{Programmiervorkurs Terminal-Anleitung}
\subsubtitle{vorkurs@d120.de}

\begin{document}
\maketitle

\section{Vorwort}
Die \enquote{Kommandozeile} ist ein mächtiges Werkzeug, mit dem man viele Aufgaben schnell und effizient erledigen kann. Man gibt einen Be\-fehl ein und erhält eine direkte Rückmeldung (meistens), ob dieser erfolgreich ausgeführt wurde oder nicht. Die Kommandozeile ist eine textbasierte Schnittstelle zum Betriebssystem. Sie wird auch als \enquote{Konsole} oder \enquote{Terminal} bezeichnet. Sie ist nicht nur auf Unix-Systemen (Linux, Mac OS,...) verfügbar, sondern auch auf Windows. Wir werden die Kommandozeile in diesem Kurs häufig verwenden.

\section{Starten der Kommandozeile}

\subsection{Windows}
Es gibt mehrere Möglichkeiten die Kommandozeile zu öffnen.
% \section*{Windows Kommandozeile öffnen (Powershell)}
\paragraph{Über den Ausführen-Dialog:}\mbox{}
\begin{enumerate}
    \item Drücke die Windows-Taste + R
    \item Gebe \texttt{powershell} ein und drücke Strg + Enter, oder wenn du die Powershell als Administrator starten möchtest, drücke Strg + Shift + Enter und bestätige die Sicherheitsabfrage
    \item[$\Rightarrow$] mit Administratorrechten lassen sich z.B. Programme installieren
\end{enumerate}
\paragraph{Für einen bestimmten Order aus dem Explorer:}\mbox{}
\begin{enumerate}
    \item Shift + Rechtsklick im Explorer-Fenster (nicht auf einer Datei)
    \item \enquote{Powershell hier öffnen} auswählen (bei neueren Windows-Versionen kann auch \enquote{Terminal hier öffnen} stehen)
\end{enumerate}
\begin{hinweis}
    Falls die \enquote{Terminal App} installiert ist, kann und sollte auch diese verwendet werden.
\end{hinweis}

\subsection{Mac OS}
Die gesuchte Anwendung heißt \enquote{Terminal}. Du kannst sie z.B. über Spotlight suchen (Command + Leertaste) oder über den Finder (Programme -> Dienstprogramme -> Terminal).

\subsection{Linux}
Auf dem meisten Distros heißt die Anwendung einfach Terminal.
Oft kann man diese mit Strg + Alt + T  öffnen.
So insbesondere auch auf den Poolrechnern.

Je nach Datei-Explorer könnt ihr auch einen Order \enquote{im Terminal Öffnen}. Meistens im Kontextmenü (Rechtsklick) zu finden.

Die Befehle in diesem Guide sind absichtlich so schlicht gehalten, dass sie auf allen gängigen Betriebssystemen funktionieren. Es gibt viele weitere Befehle, die aber nicht auf allen Systemen verfügbar sind. Wenn du mehr über die Kommandozeile erfahren möchtest, kannst du z.B. \href{https://wiki.ubuntuusers.de/Shell/Befehlsübersicht/}{hier} für Linux oder \href{https://ss64.com/ps/}{hier} für Windows nachschauen.

\section{Dateisystem}
\subsection{cd (\enquote{Change directory})}
In ein anderes Verzeichnis wechseln.
\begin{commandshell}
    @\shellprefix@cd @\textit{\PYG{l+s}{<Pfad zum Verzeichnis>}}@
\end{commandshell}
\begin{itemize}
    \item \mintinline{bash}{.} steht für das aktuelle Verzeichnis. \mintinline{bash}{..} steht für das übergeordnete Verzeichnis.
    \item Als Trennzeichen wird \mintinline{bash}{/} verwendet. (außer Windows, dort: \mintinline{text}{\})
    \item \textit{Pfad zum Verzeichnis} kann absolut (z.B. \mintinline{bash}{/home/user/test/test.txt}) oder relativ (z.B. \mintinline{bash}{../user}) sein.
    \item Das Nutzer-Verzeichnis kann mit \texttt{\textasciitilde} abgekürzt werden. (z.B. \mintinline{bash}{cd ~/test.txt})
    \item Auf Windows kann man mit \mintinline{bash}{cd /d} auch zwischen Laufwerken wechseln: \mintinline{text}{cd /d D:\MyFolder}
\end{itemize}


\subsection{ls (kurz für \enquote{list})}
\begin{defBox}
    \fatsf{Achtung:} nur für Unix-Basierte Systeme (Linux, Mac OS,...) verfügbar. Auf Windows gibt es \mintinline{bash}{dir} als Alternative.
\end{defBox}
Listet alle Dateien im aktuellen Verzeichnis auf.
\begin{commandshell}
    @\shellprefix@ls
\end{commandshell}
Versteckte Dateien werden nicht angezeigt. Um diese anzuzeigen, muss die Option \texttt{-a} verwendet werden:
\begin{commandshell}
    @\shellprefix@ls -a
\end{commandshell}

\clearpage
\subsection{dir}
\begin{defBox}
    \fatsf{Achtung:} gibt es zwar auch auf Unix-Basierten Systemen, aber dort ist \mintinline{bash}{ls} die übliche Variante. Außerdem sind die Argumente anders.
\end{defBox}
Listet alle Dateien im aktuellen Verzeichnis auf.
\begin{commandshell}[][minted language=batch]
    @\shellprefix@dir
\end{commandshell}
Versteckte Dateien werden nicht angezeigt. Um diese anzuzeigen, muss die Option \texttt{/a} verwendet werden:
\begin{commandshell}[][minted language=batch]
    @\shellprefix@dir /a
\end{commandshell}

\subsection{mv}
Verschiebt oder benennt eine Datei oder ein Verzeichnis um.
% \begin{noindent}
\begin{commandshell}
@\shellprefix@mv @\textit{\PYG{l+s}{<Name> <neuer Name>}}@
@\shellprefix@mv @\textit{\PYG{l+s}{<Pfad/Name> <neuer Pfad/neuer Name>}}@
\end{commandshell}
% \end{noindent}

\subsection{mkdir}
Erstellt ein neues Verzeichnis.
\begin{commandshell}
    @\shellprefix@mkdir @\textit{\PYG{l+s}{<Ordnername>}}@
\end{commandshell}

\subsection{cp (kurz für \enquote{copy})}
Kopiert eine Datei.
\begin{commandshell}
    @\shellprefix@cp @\textit{\PYG{l+s}{<Datei>}}@ @\textit{\PYG{l+s}{<Kopie>}}@
\end{commandshell}
Unter Unix: Ein Ordner lässt sich mit Option \textit{-r} kopieren:
\begin{commandshell}
    @\shellprefix@cp -r @\textit{\PYG{l+s}{<Ordner>}}@ @\textit{\PYG{l+s}{<Zielordner>}}@
\end{commandshell}
Unter Windows: Ordner samt Inhalt kopieren:
\begin{commandshell}[][minted language=batch]
    @\shellprefix@xcopy @\textit{\PYG{l+s}{<Ordner>}}@ @\textit{\PYG{l+s}{<Zielordner>}}@ /E
\end{commandshell}

\subsection{rm (kurz für \enquote{remove})}
Löscht eine Datei.
\begin{commandshell}
    @\shellprefix@rm @\textit{\PYG{l+s}{<Datei>}}@
\end{commandshell}
Unter Unix: Ein Ordner lässt sich mit Option \textit{-r} löschen:
\begin{commandshell}
    @\shellprefix@rm -r @\textit{\PYG{l+s}{<Ordner>}}@
\end{commandshell}
Unter Windows: Ordner samt Inhalt löschen:
\begin{commandshell}[][minted language=batch]
    @\shellprefix@rmdir @\textit{\PYG{l+s}{<Ordner>}}@ /S /Q
\end{commandshell}

\section{Programmieren}
\subsection{nano und gedit}
\begin{defBox}
    \fatsf{Hinweis:} unter Unix meist vorinstalliert, muss für den Vorkurs nicht unbedingt installiert werden
\end{defBox}
Nano ist ein Konsolen-Texteditor. Gibt man als Parameter eine existierende Datei an, wird diese geöffnet; existiert die Datei nicht, wird sie beim Speichern erstellt. Gedit ist quasi das gleiche mit graphischer Oberfläche.
%\begin{noindent}
\begin{commandshell}
@\shellprefix@nano @\textit{\PYG{l+s}{<Datei>}}@
@\shellprefix@gedit @\textit{\PYG{l+s}{<Datei>}}@
\end{commandshell}
%\end{noindent}
Innerhalb des Editors kann man mit den Pfeiltasten navigieren und wie gewohnt schreiben.\\
Mit Strg+O kann man die Datei speichern, man wird nach dem Pfad zum Speichern gefragt und kann diesen mit Enter bestätigen.\\
Mit Strg+X verlässt man den Editor.

\subsection{Kotlin}
\begin{defBox}
    \fatsf{Hinweis:} siehe Installationsanleitung
\end{defBox}
\paragraph*{Compiler}\mbox{}

Mit \textit{kotlinc} kann man kts-Skripte ausführen.
\begin{defBox}
    \fatsf{Achtung:} Die Dateiendung ist hierbei entscheidend.
\end{defBox}

\begin{commandshell}
    @\shellprefix@kotlinc -script @\textit{\PYG{l+s}{<Datei.kts>}}@
\end{commandshell}

Auf Unix geht auch:

\begin{commandshell}
    @\shellprefix@kotlin @\textit{\PYG{l+s}{<Datei.kts>}}@
\end{commandshell}
\clearpage
\paragraph*{REPL}\mbox{}

Die REPL (\enquote{\underline{R}ead-\underline{E}val-\underline{P}rint-\underline{L}oop}) \mintinline{text}{ki} (\enquote{\underline{K}otlin-\underline{I}nteractive-Shell}) kann mit dem Befehl \mintinline{text}{ki} gestartet werden. Alternativ kann auch \mintinline{text}{kotlin} ausgeführt werden, um in die standard-REPL zu gelangen. Diese ist aber nicht so komfortabel wie \mintinline{text}{ki} und wird daher nicht empfohlen.
\begin{commandshell}[][minted language=text]
    @\shellprefix@kotlin
    Welcome to Kotlin version 1.9.10 (JRE 11.0.20.1+1)
    Type :help for help, :quit for quit
    @\texttt{>>>}@ @\shellcursor@
\end{commandshell}

\begin{commandshell}[][minted language=text]
    @\shellprefix@ki
    ki-shell 0.5.2/1.7.0
    type :h for help
    [0] @\shellcursor@
\end{commandshell}

In einer Repl kannst du einfach Kotlin-Code eingeben und er wird sofort ausgeführt. Z.B.:
\begin{commandshell}[][minted language=text]
    @\shellprefix@ki
    ki-shell 0.5.2/1.7.0
    type :h for help
    [0] 2 * 3.1415
    res0: Double = 6.283
    [1] @\shellcursor@
\end{commandshell}

Alles weitere ist für die \mintinline{text}{ki}-REPL ausgelegt.

Mit \textit{:load} kann man kts-Skripte auch direkt in eine Repl laden. Wenn wir z.B. eine Datei \mintinline{text}{helloWorld.kts} haben, können wir diese mit \textit{:load} laden:
\begin{codeBlock}[]{minted language=kotlin,title=\codeBlockTitle{helloWorld.kts}}
    println("Hello World!")
\end{codeBlock}
\begin{commandshell}[][minted language=text]
    @\shellprefix@ki
    ki-shell 0.5.2/1.7.0
    type :h for help
    [0] :load helloWorld.kts
    Hello World!
    [1] @\shellcursor@
\end{commandshell}
\end{document}
